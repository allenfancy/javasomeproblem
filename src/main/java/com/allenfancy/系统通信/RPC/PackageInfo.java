package com.allenfancy.系统通信.RPC;
/**
 * 
 * RPC典型框架 ： Apache Thrift ，服务治理和DUBBO服务框架
 * RPC概述：
 *  1.什么是RPC：
 *      RPC (Remote Procedure Call Protocol)远程过程调用协议。一个通俗的概念：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象
 *      就像调用本地应用程序中的对象一样。比较正式的描述：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术协议。
 *      注意下面几点：
 *      RPC是协议：即然是协议就是规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo Thrift GRPC Hetty等。实现RPC协议的应用工具往往都会附加其他功能，例如Dubbo还包括服务管理，访问权限管理等功能
 *      网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不关心了。
 *      信息格式对其透明：我们知道在本地应用程序中，对于其某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算处理结果，调用方不关心。
 *      对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心
 *  2.PRC要素：
 *      RPC的调用者所观察到现象(而实际情况是客户端或多或少的还是需要知道一些调用RPC的细节)。但是我们是要讲解RPC的基本概念，所RPC协议内部是怎么回事要说清楚：
 *      Client： RPC协议的调用方。
 *      Server： 在RPC规范中，这个Server并不是提供RPC服务器IP，端口监听的模式。而是远程服务方法的具体实现(在Java中就是RPC服务接口的具体实现)。其中的代码是最普通的和业务相关的代码，设置其接口实现类本身都不知道将某一个RPC远程客户端调用。
 *      Stub/Proxy : RPC代理存在于客户端，因为要实现RPC框架 透明 调用，那么客户端不可能自行去管理消息格式、不可能自己去管理网络传输协议，也不可能自己去判断调用过程是否有异常。这一切工作在客户端都交给RPC框架中的"代理"层来处理。
 *      Message Protocol : 一次完整的Client-server的交互肯定是携带某种俩端都能识别的，共同约定的消息格式。RPC的消息管理层专门对网络传输所承载的消息信息进行编号和解码操作。目前流程的技术趋势不同的RPC实现，为了加强自身框架的效率都要一套或者几套私有的消息格式、
 *      Transfer/Network Protocol : 传输协议层负责管理RPC框架所使用的网络协议，网络IO模型。例如Hessian的传输协议基于HTTP(应用层协议)；而Thrift的传输协议基于TCP(传输层协议)。
 *      Selector/Processor:存在于RPC服务端，由于服务端某一个RPC接口的实现的特性。所以在RPC框架中应该有一种"负责执行RPC接口实现"。它包括：管理RPC接口的注册、判断客户端的请求权限、控制接口实现类的执行在内的各种工作。
 *      IDL：实际上IDL(接口定义语言)并不是RPC实现中所必须的。但是需要跨语言的RPC框架一定会有IDL部分的存在。这是因为要找到一个各种语言能够理解的消息结构、接口定义的描述形式。如果您的RPC实现没有考虑跨语言性，那么IDL部分就不需要包括，例如：JAVA RMI因为就是为了在JAVA语言间进行使用，所以JAVA RMI就没有相应的IDL
 *      
 *      
 */
public class PackageInfo {

}
