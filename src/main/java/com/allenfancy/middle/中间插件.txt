1.网络IO实现方式
	1.BIO方式：
		即BIO即Blocking IO，采用阻塞的方式实现。也就是一个Socket套接字需要使用一个县城来进行处理。发生建立连接，读取数据，写数据的操作时，都可能会阻塞。
	2.NIO方式：
		NIO即NonBlocking IO，基于时间驱动的思想，采用Reactor模式。这在Java实现的服务器系统中也是采用比较多的一种方式。相对于BIO，NIO的一个明显的好处是不需要为每个Socket套接字分配一个线程，而可以在一个线程中处理多个Socket套接字相关的工作。
	3.AIO方式：
		AIO即AsynchronousIO,就是异步IO。AIO采用Proactor模式。AIO和NIO的差异，AIO在进行读/写操作时，只需要强调相应的read/write方法，并且需要传入CompletionHandler(动作完成的处理器)；在动作完成后，会调用CompletionHandler，当然，在不同的系统上会有一些细微的差异，不同的语言在SDK上会有写差异。但是总体就是这样的工作方式。
		NIO的通知是发生在动作之前，是在可写、可读的时候，Selector发现这些事件后调用Handler处理。
2.如何把应用从单击扩展到分布式
	从使用者的角度来看，分布式系统就像是一个超级计算机。
	1.输入设备的变化
		分布式系统由通过网络连接的多个节点组成，那么，输入设备其实可以分为俩类，一种是互相连接的多个节点，在接收其他节点传来的信息时，该节点可以看做输入设备，另外一种就是传统意义的人际交互的输入设备。
	2.输出设备的变化
		输出设备和输入设备相仿，也可以看成两类，一种是指系统中的节点在向其它节点传递信息时，该节点可以看做是输出设备，另外一种就是传统意义的人家交互的输出设备。
	3.控制器的变化
		分布式系统是由多个节点通过网络练在一起并通过消息的传递进行协调的系统。控制器主要的作用就是协调或控制节点之间的动作和行为

3.演化
	什么是Session？
		用户在使用网站的服务，基本上需要浏览器与web服务器的多次交互。HTTP协议本身是无状态的，需要基于HTTP协议支持会话状态(Session State)的机制。而这样的机制应该可以使Web服务器从多次单独的HTTP请求看到"会话"，也就是知道哪些请求来时哪个会话的。
	实现方式：
		在会话开始的时候，分配一个唯一的会话标识(SessionId)，通过Cookie把这个标识告诉浏览器，以后每次请求的时候，浏览器都会带上这个会话标识来告诉web服务器请求属于哪个会话的。在Web服务器上，各个会话有独立的存储，保持不同会话信息。如果遇到禁用Cookie的情况，一般的做法就是把这个会话标识放到URL的参数中。
		
	解决应用服务器变为集群后的Session问题？
		解决方案？
		1.Session Sticky
			如果这样做的话，就需要负载均衡器能够根据每次请求会话标识进行请求转发。
			使用这种方式的问题：
				1.如果一台服务器宕机的话，那么这台服务器上的会话数据就会丢失。用户就需要重新登录。
				2.会话标识是应用层的信息，那么负载均衡器要将同一个会话的请求都保存到同一个web服务器上的话没救需要进行应用层解析，这个开销比第四次大。
				3.负载均衡变为了一个有状态的节点，要将会话保存到具体Web服务器的映射。和无状态的节点相比，内存消耗会更大，容灾方面会更加麻烦。
		2.Session Replication
			在Web服务器端之间增加数据的同步。通过同步就保证了不同的web服务器之间的Session数据的一致性。
			问题：
				1.同步Session数据造成了网络宽带的开销。只要Session数据有变化，就需要将数据同步到所有其他机器上，机器数越多，同步带来的网络带宽开销就越大。
				2.每台Web服务器都保存所有的Session数据，如果整个集群的Session数据很多（有很多的人在同时访问）的话，每台机器用于保存Session数据的内容占用会很严重。
		3.Session数据集中存储
			同样是希望同一个会话的请求可以发到不同的Web服务器上，刚才的Session Replication是一种解决方案，另一种方案就是把Session数据集中存储起来，然后不同Web服务器从同样的地方来获取Session。
			问题：
				1.读写Session数据引入了网络操作，这相对于本机的数据读取来说，问题就在于存在延时和不稳定性，不过我们的通信基于内网，问题不大。
				2.如果集中存储Session的机器或者集群有问题，就会影响我们的应用。
		4.Cookie Based
			Cookie Based这种解决方案对于同一个会话的不同请求也是不限制具体处理机器的。和Session Replication以及Session 数据集中管理的方案不同，这个方案是通过Cookie来传递Session数据的。
			方案不足：
				1.Cookie长度的限制。我们知道Cookie是有长度限制的，而这个也会限制Session数据的长度。
				2.安全性。Session数据本来都是服务器数据，而这个方案是让这些服务器端数据到了外部网络及客户端，因此存在安全性的问题。我们可以对写入Cookie的Session数据加密，不过对于安全来说，物理上的安全接触才是安全的。
				3.带宽消耗。这里指的不是内部Web服务器之间的带宽消耗，而是我们数据中心的整体外部宽带的消耗
				4.性能影响。每次HTTP请求和相应都带有Session数据，对于Web服务器来说，在同样的处理情况下，响应的结果输出越少，支持的并发请求就会越多。
	数据读压力变大，读写分离吧：
		1.采用数据库作为读写
			单独用一个数据库来处理读的操作，不承担写的内容。
			这个结构变化带来的问题：
				数据复制问题。
				应用对于数据源的选择问题。
			通过读库来分担主库上读的压力，那么首先就需要解决数据怎么复制到读库的问题。
		2.加速数据读取的利器-缓存
			1.数据缓存
				将热点数据，加入缓存中，当在查询的时候，需要先去缓存中去查询，如果查询到了后，直接返回结果，如果没有，就去数据库中查询，查询到数据后，在加入缓冲中。
			2.页面缓存
				除了数据缓冲外，我们还可以页面缓存。数据缓存可以加速应用在相应请求时数据读取的速度，但是最终应用返回给用户的主要还是页面，有些动态产生的页面或者页面的一些热点部分，我们可以先将这些内容缓存起来。
			3.弥补关系型数据库的不足，引入分布式存储系统
				常见的分布式存储系统有分布式文件系统，分布式Key-Value系统和分布式数据库。文件系统就是在分布式环境中由多个节点组成的工与单击文件系统一样的文件系统，它是弱格式的，内容的格式需要使用者自己来组织；而分布式key-value系统相对分布式文件系统会更加格式化一些；分布式数据库则是最格式化的方式。
				分布式存储系统自身起到了存储的作用，也就是提供数据的读写支持。
			4.垂直拆分后的单击遇到瓶颈，数据水平拆分
				与数据垂直拆分对应的还有数据水平拆分。数据水平拆分就是把同一个表的数据拆到俩个数据库中。
				数据水平拆分与读写分离的区别是，读写分离解决的是读压力的问题，对于数据量大或者更新量的情况并不起作用。数据水平拆分与数据垂直拆分的区别是，垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据中。
				最后，由于同一个业务的数据被拆分到了不同的数据库中，因此一些查询需要从俩个数据库中取数据，如果数据量太大而需要分页，就比较困难。
				不过，一旦我们能够完成数据的水平拆分，我们将能够很好地对应数据量及写入增长情况。具体如何完成数据水平拆分。
			5.消息中间件
				面向消息的系统是在分布式系统中完成消息的发送和接收的基础软件
				消息中间件有俩个常被提及的好处，即异步和解耦。
4.构建Java中间件
	三个领域的中间件：
		1.远程过程调用和对象访问中间件：主要解决分布式环境下应用的互相访问问题。
		2.消息中间件：解决应用之间的消息传递、解耦、异步的问题
		3.数据访问中间件：主要解决应用访问数据库的共性问题的组件。
	并发编程的类，接口和方法
	
    ClassLoader是Java中一项非常关键的技术。将服务框架自身用的类与应用用到的类都控制在User-Defined Class Loader 级别，这样就实现了相互的隔离。
    
    数据库的水平拆分和垂直拆分：
    垂直拆分会带来如下的影响：
    	单击的ACID保证被打破。这个时候就会面临要么放弃原来的单击事务，修改实现，要么引入分布式事务
    	一些Join操作会变得比较困难，因为数据可能已经在俩个数据库中了，所以不能很方便第利用数据自身的Join了，需要应用或者其他方式来解决
    	靠外键去进行约束的场景会影响
    水平拆分会带来的影响：
    	同样有可能有ACID被打破的情况
    	同样有可能有Join操作被影响的情况
    	靠外键去进行约束的场景会有影响
    	依赖单裤的自增序列生成唯一ID会受影响
    	针对单个逻辑意义上的表的查询要跨库
    了解分布式事务：
    	1.分布式事务模型与规范
    		在X/Open DTP模型中定义了三个组件，即Application Program、Resource Manager、Transaction Manager，分别介绍：
    		Application Program(AP),即应用程序，可以理解为使用DTP模型的程序，它定义了事务边界，并定义了构成事务的应用程序的特定操作。
    		Resource Manager(RM) ,资源管理器，可以理解为一个DBMS系统，或者消息服务器管理系统。应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。资源管理器提供了存储共享资源的支持
    		Transaction Manager(TM),事务管理器，负责协调和管理事务，提供AP应用程序编码接口并管理资源管理器。事务管理器向事务指定标识，监视它们的进程，并负责处理事务的完成和失败。事务分值标识(称为XID)由TM指定，以标识一个RM内的全局事务和特定分支。它是TM中日志与RM中日志之间的相关标记。
    		在DTP中还定义了其他几个概念，如下：
    		事务：一个事务是一个完整的工作单元，由多个独立的计算任务组成，这多个任务在逻辑是原子的
    		全局事务：一次性操作多个资源管理器的事务就是全局事务。
    		分支事务：在全局事务中，每一个资源管理器有自己独立的任务，这些任务的集合是这个资源管理器的分支任务
    		控制现场：用来表示一个工作现场，主要管理AP，TM和RM三者线程，也就是事务上下文环境。简单地说，就是用来标识全局事务和分支事务关系线程。
    		
    		Paxos：
    		Quorum:集群内数据一致性的算法实例
		
				
总结：
	随着数据量、访问量的增大，我们会对数据进行分库分别，这会为数据访问带来一些共性问题，数据层正是为此而产生的。其实应用在进行数据读或写的时候，不仅会用到数据库，还会用到分布式文件系统、缓存系统、搜索系统等。

6.消息中间插件
	如何解决消息发送一致性
		1.消息发送一致性的定义
			消息发送一致性是指产生消息的业务动作与消息发送的一致，就是说，如果业务操作成功了，那么由这个操作产生的消息一定要发送出去，否则就丢失消息了。而另一方面，如果这个业务行为没有发生或者失败，那么就不应该把消息发出去的。
			JMS消息模型中，有Queue和Topic之分，所以前面的Destination ConnectionFactory Connection Session MessageConsumer MessageProducer都有对应的子接口。
			JMS Common							PTP Domain   						Pub/Sub Domain
		ConnectionFactory 					QueueConnectionFactory				TopicConnectionFactory
		Connection							QueueConnection						TopicConnection
		Destination							Queue								Topic
		Session								QueueSession						TopicSession
		MessageProducer						QueueSender							TopicPublisher
		MessageConsumer						QueueReceiver						TopicSubscriber
	JMS API中，我们看到很多的以XA开头的接口，它们其实就是支持XA协议的接口：
	XA系列接口与对应的非XA系列接口
	XA系列接口名											对应的非XA接口名称
	XAConnectionFactory								ConnectionFactory
	XAQueueConnectionFactory						QueueConnectionFactory
	XATopicConnectionFactory						TopicConnectionFactory
	XAConnection									Connection
	XAQueueConnection								QueueConnection
	XATopicConnection								TopicConnection
	XAQueueSession									QueueSession
	XATopicSession									TopicSession
 在XA系列的接口集中在ConnectionFactory Connection 和Session上，而MessageProducer QueueSender TopicPublisher MessageConsumer QueueReceiver和TopicSubscriber则没有对应的XA对象。这是因为事务的控制在Session层面上的，而Session是通过Connection创建的，Connection通过ConnectionFactory创建的，所以，这三个接口需要有XA系列对应的接口的定义。Session Connection ConnectionFactory在Queue和Topic模型下对应的各个接口也存在相应的XA系列的对应接口
 消息、发送者、接收者与几个基本元素之间的关系：
 ConenctionFactory -- > Connection  -- > Session -- > Message
 Destination + Session  -- > MessageProducer
 Destination + Session  -- > MessageConsumer
 在JMS中，如果不使用XA系列的接口实现，那么我们就无法直接得到发送消息给消息中间件及业务操作这俩个事情的事务保证，而JMS中定义的XA系列的接口就是为了实现分布式事务的支持。
 引入分布式事务，这回带来一些开销并增加复杂性。
 对于业务操作有限制，要求业务操作的资源必须支持XA协议，才能够与发送小米一起哎做分布式事务。这回称为一个限制，因为并不是所有需要与发消息一起做分布式事务的业务操作都支持XA协议
 解决一致性的方案：
 	发送消息给消息中间件
 	消息中间件入库消息
 	消息中间件返回结果
 	业务操作
 	发送业务操作结果给消息中间件
 	更改存储中消息状态
 如何解决消息中间件与使用者的强依赖问题？
 提供消息中间件系统的可靠性，但是没有办法保证百分之百可靠
 对于消息中间件系统中影响业务操作进行的部分，使其可靠性与业务自身的可靠性相同
 可以提供弱依赖的支持，能够较好地保证一致性。
 业务操作与发送消息一致性的方案所带来的俩个限制：
 1.需要确定要发送的消息的内容。
 2.需要实现对业务的检查。
 消息模型对消息接收的影响：
 	前面讲述了消息发送端的内容，我们接下来看一下消息模型，在JMS中，有Queue(点对点)和Topic(发布/订阅)俩种模型
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		